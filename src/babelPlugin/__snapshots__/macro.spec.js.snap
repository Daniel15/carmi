// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`1. macros 1`] = `
"
const carmi = require('./macro')

const modelBuilder = carmi\`
  const {root} = require('../..')
  module.exports = {all: root.get('list'), first: root.get('list').get(0)}
\`

      ↓ ↓ ↓ ↓ ↓ ↓

const modelBuilder = (function () {
  'use strict';
  function model($model, $funcLib) {
    const $res = { $model };const $listeners = new Set();const $trackingMap = new WeakMap();const $trackedMap = new WeakMap();const $trackingWildcards = new WeakMap();const $invalidatedMap = new WeakMap();const $parentObjectMap = new WeakMap();const $parentKeyMap = new WeakMap();const $invalidatedRoots = new Set();let $tainted = new WeakSet();$invalidatedMap.set($res, $invalidatedRoots);const untrack = ($targetKeySet, $targetKey) => {
      const $tracked = $trackedMap.get($targetKeySet);if (!$tracked || !$tracked[$targetKey]) {
        return;
      }$tracked[$targetKey].forEach(({ $sourceObj, $sourceKey, $target }) => {
        const $trackingSource = $trackingMap.get($sourceObj);$trackingSource[$sourceKey].delete($target);
      });delete $tracked[$targetKey];
    };const invalidate = ($targetKeySet, $targetKey) => {
      if ($targetKeySet.has($targetKey)) {
        return;
      }$targetKeySet.add($targetKey);untrack($targetKeySet, $targetKey);if ($parentObjectMap.has($targetKeySet)) {
        invalidate($parentObjectMap.get($targetKeySet), $parentKeyMap.get($targetKeySet));
      }
    };function setOnObject($target, $key, $val, $invalidates) {
      let $changed = false;let $hard = false;if ($invalidates) {
        if (typeof $target[$key] === \\"object\\" && $target[$key] && $target[$key] !== $val) {
          $hard = true;
        }if ($hard || $target[$key] !== $val || typeof $val === \\"object\\" && $tainted.has($val) || !$target.hasOwnProperty($key) && $target[$key] === undefined) {
          $changed = true;triggerInvalidations($target, $key, $hard);
        }
      }$target[$key] = $val;return $changed;
    }function triggerInvalidations($sourceObj, $sourceKey, $hard) {
      $tainted.add($sourceObj);const $track = $trackingMap.get($sourceObj);if ($track && $track.hasOwnProperty($sourceKey)) {
        $track[$sourceKey].forEach(($soft, $target) => {
          if (!$soft || $hard) {
            invalidate($target[0], $target[1]);
          }
        });
      }if ($trackingWildcards.has($sourceObj)) {
        $trackingWildcards.get($sourceObj).forEach($targetInvalidatedKeys => {
          invalidate($targetInvalidatedKeys, $sourceKey);
        });
      }
    }$invalidatedRoots.add(\\"all\\");function $allBuild() {
      const newValue = $model[\\"list\\"];setOnObject($res, \\"all\\", newValue, false);$invalidatedRoots.delete(\\"all\\");return $res.all;
    }$invalidatedRoots.add(\\"first\\");function $firstBuild() {
      const newValue = $res[\\"all\\"][0];setOnObject($res, \\"first\\", newValue, false);$invalidatedRoots.delete(\\"first\\");return $res.first;
    }let $inBatch = false;function recalculate() {
      if ($inBatch) {
        return;
      }$invalidatedRoots.has(\\"all\\") && $allBuild();$invalidatedRoots.has(\\"first\\") && $firstBuild();$tainted = new WeakSet();$listeners.forEach(callback => callback());
    }Object.assign($res, {}, { $startBatch: () => $inBatch = true, $endBatch: () => {
        $inBatch = false;recalculate();
      }, $runInBatch: func => {
        $inBatch = true;func();$inBatch = false;recalculate();
      }, $addListener: func => {
        $listeners.add(func);
      }, $removeListener: func => {
        $listeners.delete(func);
      } });recalculate();return $res;
  }return model;
})();
"
`;
